#
java8中对hashmap的改进：
1、从java7中改进了
java7对hashcode计算是进行了4次亦或运算得到的hashcode。但是java8之后，使用了高位与地位进行亦或，使其更加均匀
而且在java8中引入了红黑树在链表长度超过8时才会进行长度转化为红黑树
为什么选择8是因为在根据概率学统计       按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表


1、计算机网络tcp/ip
2、spring中的观察者，动态代理模式，单例，工厂模式
3、java的反射原理和类加载
4、mysql索引的时效以及慢查询优化
5、聚集索引和非聚集索引
6、java hashmap的get和put

7、B+树和b树的区别
8、mysql的事务隔离级别
9、redis情况
10、threadlocal的作用
11、java线程池的几种状态
线程池的运行策略：
线程池提交任务时的执行顺序如下：
向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。

如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。
如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。
如果已经达到了最大线程数，则执行指定的拒绝策略。这里需要注意队列的判断与最大线程数判断的顺序，不要搞反。


第1种是：固定大小线程池，特点是线程数固定，使用无界队列，适用于任务数量不均匀的场景、对内存压力不敏感，但系统负载比较敏感的场景；
第2种是：cached线程池，特点是不限制线程数，适用于要求低延迟的短期任务场景；
第3种是：单线程线程池，也就是一个线程的固定线程池，适用于需要异步执行但需要保证任务顺序的场景；
第4种是：scheduled线程池，适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式；
12、java锁知识
reentrantlock实现方式类似，semaphore也是基于aqs，差别在于reentrantlock是独占锁，semaphore是共享锁。
    
最好可以问一下如: 公司的技术架构啊、去了公司承担何种任务啊什么的，体现你的求职欲望和好学的精神（捂脸）。

附redis关于缓存雪崩和缓存穿透，热点key
穿透
穿透：频繁查询一个不存在的数据，由于缓存不命中，每次都要查询持久层。从而失去缓存的意义。

解决办法： 持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key) ,如果有直接返回空，没有则查询后返回，

                  注意insert时需清除查询的key，否则即便DB中有值也查询不到(当然也可以设置空缓存的过期时间）

雪崩
雪崩：缓存大量失效的时候，引发大量查询数据库。
解决办法：①用锁/分布式锁或者队列串行访问

                  ②缓存失效时间均匀分布

热点key
热点key:某个key访问非常频繁，当key失效的时候有打量线程来构建缓存，导致负载增加，系统崩溃。

解决办法：

①使用锁，单机用synchronized,lock等，分布式用分布式锁。

②缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。

③在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。